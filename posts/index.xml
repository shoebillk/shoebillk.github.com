<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on BH Kim's blog</title><link>https://byounghoonkim.github.io/posts/</link><description>Recent content in Posts on BH Kim's blog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 10 Jun 2020 23:06:31 +0900</lastBuildDate><atom:link href="https://byounghoonkim.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 패키지 이름(Package Names)</title><link>https://byounghoonkim.github.io/posts/golang-package-names/</link><pubDate>Wed, 10 Jun 2020 23:06:31 +0900</pubDate><guid>https://byounghoonkim.github.io/posts/golang-package-names/</guid><description>원문 - The Go Blog - Package Names (Sameer Ajmani - 4 February 2015) (원문은 Creative Commons Attribution 3.0 License 로 배포 되므로 원작자의 동의 없이 번역 및 배포 합니다.) 개요 Go 코드는 패키지로 구성된다. 패키지 내부에서</description><content type="html"><![CDATA[<p>원문 - <a href="https://blog.golang.org/package-names">The Go Blog - Package Names</a> (Sameer Ajmani - 4 February 2015)</p>
<p>(원문은 Creative Commons Attribution 3.0 License 로 배포 되므로 원작자의 동의 없이 번역 및 배포 합니다.)</p>
<h1 id="개요">개요</h1>
<p>Go 코드는 패키지로 구성된다.
패키지 내부에서는 정의된 어떤 식별자(이름)도 참조할 수 있지만 패키지의 클라이언트는 노출된 타입, 함수, 상수 그리고 변수만 참조할 수 있다.
이런 참조는 항상 <code>foo.Bar</code> 와 같은 프리픽스를 포함한다.
<code>foo.Bar</code>는 임포트한 <code>foo</code> 패키지에서 노출된 이름 <code>Bar</code>을 참조한다.</p>
<p>좋은 패키지 이름은 코드를 더 좋게 만든다.
좋은 패키지 이름은 패키지 내용에 대한 컨텍스트를 제공하고, 패키지 사용자가 패키지가 무엇을 위한 것이고 어떻게 사용하는지를 이해하기 쉽게 한다.
또한 좋은 패키지 이름은 패키지 매인테이너들이 패키지에 그것과 관련된 어떤 것을 포함하고 포함하지 않을지 결정하는 것을 돕는다.</p>
<p>잘 지어진 패키지 이름은 필요한 코드를 쉽게 찾을 수 있도록 만든다.</p>
<p>이펙티브 Go 문서는 패키지, 타입, 함수, 변수 네이밍에 대한 <a href="https://golang.org/doc/effective_go.html#names">가이드라인</a>을 제공한다.
이 블로그는 그 토론을 확장하고 표준 라이브러리에서 찾아낸 이름들 확인해 본다.
또한 나쁜 이름에 대해 살펴보고 어떻게 고칠지에 대해서도 토론한다.</p>
<h1 id="패키지-이름">패키지 이름</h1>
<p>좋은 패키지 이름은 짧고 간결하다.
<code>언더바(under_scores)</code>나 <code>대소문자 섞어쓰기(mixedCaps)</code>가 없이 소문자로 이뤄진다.
좋은 패키지 이름은 간단한 명사로 이뤄진다. 다음 처럼 말이다:</p>
<ul>
<li><code>time</code> (시간 측정 및 출력 기능 제공)</li>
<li><code>list</code> (이중 링크드 리스트 구현)</li>
<li><code>http</code> (HTTP 서버 및 클라이언트 구현 제공)</li>
</ul>
<p>다른 언어의 일반적인 이름 스타일은 Go 프로그램에서는 관용적이지 않을 수 있다.
여기 다른 언어에서는 좋은 스타일의 이름일지도 모르지만 Go에서는 그렇지 않은 이름 예시가 2가지가 있다:</p>
<ul>
<li><code>computeServiceClient</code></li>
<li><code>priority_queue</code></li>
</ul>
<p>Go 패키지는 타입과 함수를 노출한다.
예를 들면, <code>compute</code> 패키지는 여러 클라이언트들 중에 계산(compute) 기능만 분할하여 서비스를 이용할 수 있는 메소드들을 노출한 <code>Client</code> 타입을 노출할 수 있다.</p>
<p><strong>약자는 신중하게 사용한다.</strong> 약자가 프로그래머들에에 익숙하다면 패키지 이름을 약자로 만들 수도 있다.
널리 사용되는 패키지에는 종종 축약된 이름이 있다:</p>
<ul>
<li><code>strconv</code> (string conversion)</li>
<li><code>syscall</code> (system call)</li>
<li><code>fmt</code> (formatted I/O)</li>
</ul>
<p>반면에, 모호하거나 명확하지 않다면 패키지 이름을 축약하지 마라.</p>
<p><strong>사용자에게서 좋은 이름을 빼앗지 마라.</strong> 클라이언트 코드에서 일반적으로 사용되는 이름들은 패키지 이름으로 피해야 한다.
예를 들면, buf는  버퍼에 대한 좋은 변수명이기 때문에 buffered I/O 패키지는 <code>buf</code>아 아니라 <code>bufio</code>로 불린다.</p>
<h1 id="패키지-컨텐츠-이름">패키지 컨텐츠 이름</h1>
<p>클라이어트 코드는 패키지의 이름과 패키지 컨텐츠의 이름을 함께 사용하기 때문에 그 둘은 연결되어 있다(coupled).
패키지를 설계할 때는 클라이언트 쪽 관점을 가져라.</p>
<p><strong>말더듬기(반복)를 피해라.</strong> 클라이언트 코드는 패키지 이름을 패키지 컨텐츠를 참조하는데 프리픽스로 사용하므로 패키지 컨텐츠의 이름은 패키지의 이름을 반복할 필요가 없다.
<code>http</code> 패키지에서 제공하는 HTTP 서버는 <code>HTTPServer</code>가 아니라 <code>Server</code>라고 불린다.
클라이언트 코드는 <code>http.Server</code> 라고 이 타입을 참고할 것이기 때문에 모호하지 않다.</p>
<p><strong>함수 이름을 단순화 해라.</strong> 함수가 <code>pkg.Pkg</code> (또는 <code>*pkg.Pkg</code> ) 타입의 값을 리턴한다면, 혼동 없이 함수 이름에서 타입 이름을 생략할 수 있다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>                                  <span class="c1">// start is a time.Time
</span><span class="c1"></span><span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Kitchen</span><span class="p">,</span> <span class="s">&#34;6:06PM&#34;</span><span class="p">)</span>         <span class="c1">// t is a time.Time
</span><span class="c1"></span><span class="nx">ctx</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>  <span class="c1">// ctx is a context.Context
</span><span class="c1"></span><span class="nx">ip</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">userip</span><span class="p">.</span><span class="nf">FromContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>                    <span class="c1">// ip is a net.IP
</span></code></pre></div><p><code>pkg</code> 패키지의 <code>New</code>라는 이름의 함수는 <code>pkg.Pkg</code> 타입의 값을 리턴한다.
이는 그 타입을 클라이언트 코드에서 사용하기 위한 표준 엔트리 포인트이다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">q</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>  <span class="c1">// q is a *list.List
</span></code></pre></div><p>어떤 함수가 <code>pkg.T</code> 타입의 값을 리턴하고 <code>T</code>가 <code>Pkg</code>가 아니라면, 클라이언트 코드가 이해하기 쉽도록 함수 이름에 <code>T</code>를 포함할 수도 있다.
여러 New 같은 함수를 가진 패키지의 일반적인 상황은 다음과 같다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">ParseDuration</span><span class="p">(</span><span class="s">&#34;10s&#34;</span><span class="p">)</span>  <span class="c1">// d is a time.Duration
</span><span class="c1"></span><span class="nx">elapsed</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>         <span class="c1">// elapsed is a time.Duration
</span><span class="c1"></span><span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>          <span class="c1">// ticker is a *time.Ticker
</span><span class="c1"></span><span class="nx">timer</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>            <span class="c1">// timer is a *time.Timer
</span></code></pre></div><p>서로 다른 패키지들에서 타입 이름들이 동일할 수 있다. 왜냐하면 클라이언트 코드 관점에서 그런 이름들은 패키지 이름으로 구별되기 때문이다.
예를 들면, 표준 라이브러리는 <code>jpeg.Reader</code>, <code>bufio.Reader</code> 그리고 <code>csv.Reader</code> 를 포함해 <code>Reader</code> 라는 이름의 타입을 여러 개 가지고 있다.
각 패키지 이름은 <code>Reader</code>와 만나 좋은 타입 이름을 만든다.</p>
<p>패키지 이름이 패키지 컨텐츠를 위해 이런 의미의 프리픽스라고 생각할 수 없다면, 패키지 추상화 경계가 잘못된 것이다.
클라이언트가 사용하는 것처럼 코드를 작성하고, 결과가 나쁘다면 패키지를 재구성하라.
이 접근법이 클라이언트들이 이해하기 쉽고 패키지 개발자들이 유지보수하기 쉬운 패키지를 만들어 낼 것이다.</p>
<h1 id="패키지-경로">패키지 경로</h1>
<p>Go 패키지는 이름과 경로를 모두 가지고 있다.
패키지 이름은 소스 파일의 package 문(statement)에 의해서 기술된다. 클라이언트 코드는 이를 패키지의 노출된 이름을 위한 프리픽스로 사용한다.
클라이언트 코드는 패키지를 임포트할 때 패키지 경로를 사용한다.
관례적으로, 패키지 경로의 마지막 요소가 패키지 이름이다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;context&#34;</span>                <span class="c1">// package context
</span><span class="c1"></span>    <span class="s">&#34;fmt&#34;</span>                    <span class="c1">// package fmt
</span><span class="c1"></span>    <span class="s">&#34;golang.org/x/time/rate&#34;</span> <span class="c1">// package rate
</span><span class="c1"></span>    <span class="s">&#34;os/exec&#34;</span>                <span class="c1">// package exec
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>빌드 도구는 패키지 경로를 디렉토리에 맵핑한다.
Go 도구(go tool)는 <code>$GOPATH/src/github.com/user/hello</code> 디렉토리 내에서 <code>&quot;github.com/user/hello&quot;</code> 경로의 소스 파일을 찾기 위해 <a href="https://golang.org/doc/code.html#GOPATH">GOPATH</a>환경 변수를 이용한다.
(물론 이 상황은 친숙하지만, 용어와 패키지의 구조를 명확히 하는 것이 중요하다.)</p>
<p><strong>디렉토리들</strong> 표준 라이브러리는 관련 프로토콜과 알고리즘 패키지를 그룹화 하기 위해 <code>crypto</code>, <code>container</code>, <code>encoding</code>, 그리고 <code>image</code> 같은 디렉토리를 사용한다.
이 디렉토리들과 패키지들 사이에는 실제적인 관계는 없다; 디렉토리는 단지 파일들을 정렬하는 방법만 제공한다.
모든 패키지는 순환 임포트를 만들지 않는 한 다른 어떤 패키지든 임포트할 수 있다.</p>
<p>다른 패키지의 타입이 모호하지 않은 동일한 이름을 가질 수 있는 것 처럼, 다른 디렉토리 내의 패키지도 동일한 이름을 가질 수 있다.
예를 들면, <a href="https://golang.org/pkg/runtime/pprof">runtime/pprof</a> 은 <a href="https://github.com/google/pprof">pprof</a> 프로파일 툴을 제공하고, <a href="https://golang.org/pkg/net/http/pprof">net/http/pprof</a>는 HTTP 포맷의 프로파일 데이터를 보여주는 HTTP 엔드포인트를 제공한다.
클라이언트 코드는 패키지를 임포트 하기 위해 패키지 경로를 사용하기 때문에 혼란이 없다.
소스 파일이 두 가지 <code>pprof</code> 패키지를 임포트해야 하면, 패키지 하나 또는 둘다 리네임<a href="https://golang.org/ref/spec#Import_declarations">rename</a> 할 수 있다.
임포트된 패키지를 리네임할 때, 변경될 로컬 이름도 패키지 이름과 동일한 가이드라인을 따라야 한다(소문자 사용, <code>언터바(under_scores)</code> 금지, <code>대소문자 혼용(mixedCaps)</code> 금지 ).</p>
<h1 id="나쁜-패키지-이름들">나쁜 패키지 이름들</h1>
<p>나쁜 패키지 이름은 코드 탐색과 유지를 어렵게 한다.
여기 나쁜 이름을 인지하고 수정하는 몇 가지 가이드라인이 있다.</p>
<p><strong>무의미한 패키지 이름을 피하라.</strong> <code>util</code>, <code>common</code>, 또는 <code>misc</code> 등의 패키지 이름은 클라이언트에게 패키지 컨텐츠에 대한 정보를 제공하지 못한다.
이는 패키지 사용을 힘들게 하고 매인테이너들이 패키지에 집중력을 유지하기 힘들게 한다.
이런 패키지에는 시간이 지남에 따라, 불필요한 이름은 특히 커다란 프로그램에서 불필요하고 현저히  컴파일을 느리게 만드는 종속성들이 누적된다.
이런 패키지 이름들은 일반적이기 때문에, 임포트한 클라이언트 코드의 다른 패키지와 충돌할 가능성이 높고 다른 것들과 구별하기 위해 이름을 다시 만들게 강요하게 된다.</p>
<p><strong>일반적인 패키지를 분리하라.</strong> 이런 패키지를 수정하려면, 공통 이름을 가진 타입과 함수를 찾아 별도의 패키지로 만들라.
예를 들면, 이런 패키지가 있다면</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">util</span>
<span class="kd">func</span> <span class="nf">NewStringSet</span><span class="p">(</span><span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">SortStringSet</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>클라이언트 코드는 다음과 같고</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">NewStringSet</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">SortStringSet</span><span class="p">(</span><span class="nx">set</span><span class="p">))</span>
</code></pre></div><p>컨텐츠에 적당한 이름을 선택해 이 함수들을 <code>util</code>에서 분리해 새 패키지로 넣는다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">stringset</span>
<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">Sort</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>그러면 클라이언트 코드는 다음과 같이 되고</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span> <span class="o">:=</span> <span class="nx">stringset</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">stringset</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">set</span><span class="p">))</span>
</code></pre></div><p>변경한 후에는 새 패키지를 개선하는 방법을 쉽게 알수 있다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">stringset</span>
<span class="kd">type</span> <span class="nx">Set</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span>
<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Set</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Set</span><span class="p">)</span> <span class="nf">Sort</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div><p>클라이언트 코드도 더 간단해진다:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span> <span class="o">:=</span> <span class="nx">stringset</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">set</span><span class="p">.</span><span class="nf">Sort</span><span class="p">())</span>
</code></pre></div><p>패지키 이름은 디자인의 중요한 한 부분이다.
여러분의 프로젝트에서 의미 없는 패키지 이름을 제거하라.</p>
<p><strong>모든 API를 위한 단독 패키지를 사용하지 마라</strong>  많은 프로그래머들이 코드 베이스의 진입점을 찾기 쉽게 만들거라 생각하고 좋은 의도로 모든 프로그램의 노출 인터페이스를 <code>api</code>, <code>types</code>, <code>interfaces</code>와 같은 이름의 단독 패키지에 둔다.
이는 실수이다.
이런 패키지도<code>util</code>나 <code>common</code> 이름의 패키지와 마단가지로 제한 없이 커지고, 사용자들에게 사용 지침이나 정교한 종속성을 제공하지 않고, 다른 임포트 패키지와 충돌하는 등의 문제를 유발한다.
구현으로부터 공개 패키지를 분리하기 위해 디렉토리를 사용하는 등으로 패키지를 분리하라.</p>
<p><strong>불필요한 패키지 이름 충돌을 피하라</strong> 다른 디렉토리에 패키지는 동일한 이름을 가질 수 있지만, 자주 함께 사용되는 패키지들은 고유한 이름을 가져야 한다.
자주 함께 사용되는 패키지들이 이름이 같으면 혼동을 야기하고 클라이언트 코드에 로컬 리네임을 필요하게 만든다.
동일한 이유로 <code>io</code>나 <code>http</code> 같은 유명한 표준 패키지의 이름을 사용하는 것을 피해라.</p>
<h1 id="결론">결론</h1>
<p>패키지 이름은 Go 프로그램에서 좋은 이름을 위한 중심이다.
좋은 패키지 이름을 선택하기 위해 시간을 투자해서 코드를 잘 조직화 해야 한다.
이는 사용자가 패키지를 이해하고 사용하는데 도움이 되고 메인테이너들이 패키지를 우아하게 성장시키는데 도움이 된다.</p>
<h1 id="더-읽을거리">더 읽을거리</h1>
<ul>
<li><a href="https://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://golang.org/doc/code.html">How to Write Go Code</a></li>
<li><a href="https://blog.golang.org/organizing-go-code">Organizing Go Code (2012 blog post)</a></li>
<li><a href="https://talks.golang.org/2014/organizeio.slide">Organizing Go Code (2014 Google I/O talk)</a></li>
</ul>
]]></content></item><item><title>Vim 입력모드 노말모드 전환시 한/영 자동 전환하기</title><link>https://byounghoonkim.github.io/posts/vim-kor-eng-auto-switch/</link><pubDate>Sat, 23 May 2020 22:06:31 +0900</pubDate><guid>https://byounghoonkim.github.io/posts/vim-kor-eng-auto-switch/</guid><description>Vim에서 한글 입력 중에 Esc로 노말 모드 진입할 때 다시 영문으로 바꿔줘야 하는 불편함이 있다. 이 문제를 해결해 보려고 여러 사람들이 여러 방법을 시도 했고 그 흔적</description><content type="html"><![CDATA[<p>Vim에서 한글 입력 중에 Esc로 노말 모드 진입할 때 다시 영문으로 바꿔줘야 하는 불편함이 있다.</p>
<p>이 문제를 해결해 보려고 여러 사람들이 여러 방법을 시도 했고 그 흔적들은 아래 블로그 글들에서 볼 수 있다.</p>
<ul>
<li><a href="http://seorenn.blogspot.com/2011/04/vim-vim-esc.html">Vim Vim에서 ESC를 눌렀을 때 영문 상태로 전환하기 - Seorenn SIGSEGV</a></li>
<li><a href="https://johngrib.github.io/blog/2017/05/04/input-source/">Vim 사용시 한/영 전환 문제 해결하기 - 기계인간 John Grib</a></li>
<li><a href="https://coldmater.tistory.com/177">VIMOS X한글 입력 상태에서 노멀모드 복귀 후 영어 입력소스로 전환하기 (feat. hammerspoon, autohotkey)</a></li>
</ul>
<p>위 블로그들에서 소개된 방법과 별개로 im-select 라는 툴을 이용하는 방법을 소개한다.
이 방법을 소개하는 이유는 내게 가장 잘 맞았고 기대한 대로 잘 동작하며 Visual Studio Code 의 Vim Mode에서도 비슷한 방법을 적용할 수 있기 때문이다!</p>
<p>아래 설명은 macOS 환경 기준이다.</p>
<p>(다른 환경은 시도해 보지 않았다.)</p>
<h2 id="im-select-설치하기">im-select 설치하기</h2>
<p>아래 명령으로  im-select라는 툴을 설치한다.</p>
<p>(참고 - <a href="https://github.com/daipeihust/im-select">https://github.com/daipeihust/im-select</a>)</p>
<pre><code>curl -Ls https://raw.githubusercontent.com/daipeihust/im-select/master/install_mac.sh | sh
</code></pre><p>위 명령을 실행하면 /usr/local/bin 경로 아래 im-select 라는 실행 파일이 설치된다.</p>
<h2 id="brglngvim-im-select-플러그인-설치">brglng/vim-im-select 플러그인 설치</h2>
<p>&lsquo;brglng/vim-im-select&rsquo;라는 Vim 플러그인을 설치한다.</p>
<p>(참고 - <a href="https://github.com/brglng/vim-im-select">https://github.com/brglng/vim-im-select</a>)</p>
<p>(vim-plug를 통해 플러그인을 설치했다. 플러그인을 설치하는 방법은 <a href="https://github.com/junegunn/vim-plug">vim-plug</a> 페이지를 참고한다.)</p>
<pre><code>call plug#begin('~/.vim/plugged')
    Plug 'brglng/vim-im-select'
call plug#end()
</code></pre><p>설치를 완료하면 아래와 같이 한글 입력이 가능한 입력 모드에서
Esc 키를 한번 누르면 영문으로 입력 언어가 변경되면서 노말 모드로 진입하게 되어
추가적인 IME 전환이 필요 없어진다.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://player.vimeo.com/video/421942102" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="vimeo video" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
 </div>

<p>이 방법의 모드 전환 시 마다 im-select 프로세스를 실행하기 때문에 저사양 환경에서 입력 전환이 조금 지연되는 단점이 있다.</p>
<p>하지만 설정이 비교적 쉽고 사양만 따라 준다면 기대한 대로 잘 동작한다.</p>
]]></content></item><item><title>Docker로 Golang 프로젝트 빌드 하기</title><link>https://byounghoonkim.github.io/posts/building_golang_using_docker/</link><pubDate>Fri, 25 Oct 2019 22:19:22 +0900</pubDate><guid>https://byounghoonkim.github.io/posts/building_golang_using_docker/</guid><description>새로운 Golang 버전이 나오면 내 프로젝트가 잘 빌드 되는지 확인해 보고 싶을 때가 있다. 또 다른 버전에서 프로젝트가 잘 빌드 되는지 확인해 보고 싶을 때도 있다. 여러 Golang 버전을</description><content type="html"><![CDATA[<p>새로운 Golang 버전이 나오면 내 프로젝트가 잘 빌드 되는지 확인해 보고 싶을 때가 있다.
또 다른 버전에서 프로젝트가 잘 빌드 되는지 확인해 보고 싶을 때도 있다.</p>
<p>여러 Golang 버전을 관리하는 방법은 <a href="https://github.com/moovweb/gvm">gvm</a> 도 있지만 여러가지 설정도 해야 하고 필요한 버전들을 설치해야 해서 조금 불편할 수도 있다.</p>
<p>Docker를 이용하면 간단히 프로젝트를 빌드해 볼 수 있다. 그 방법을 간단히 알아 보자.</p>
<h2 id="샘플-프로젝트">샘플 프로젝트</h2>
<p>빌드할 프로젝트 hello라는 프로젝트를 만들고 main.go 파일을 작성한다.</p>
<pre><code>hello
├── compile.sh
└── main.go
</code></pre><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="빌드-하기">빌드 하기</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GOLANG_VERSION</span><span class="o">=</span><span class="s2">&#34;1.13.1&#34;</span>

<span class="nv">GOX_INST_CMD</span><span class="o">=</span><span class="s2">&#34;go get github.com/mitchellh/gox&#34;</span>
<span class="nv">GOX_BUILD_CMD</span><span class="o">=</span><span class="s2">&#34;gox -output=build/{{.OS}}/{{.Arch}}/{{.Dir}}&#34;</span>

<span class="nv">PROJECT_DIR</span><span class="o">=</span><span class="sb">`</span>basename <span class="s2">&#34;</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">&#34;</span><span class="sb">`</span>

docker run -it --rm <span class="se">\
</span><span class="se"></span>	-v <span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>:/<span class="nv">$PROJECT_DIR</span> <span class="se">\
</span><span class="se"></span>	golang:<span class="nv">$GOLANG_VERSION</span> <span class="se">\
</span><span class="se"></span>	bash -c <span class="s2">&#34;cd /</span><span class="nv">$PROJECT_DIR</span><span class="s2"> &amp;&amp; </span><span class="nv">$GOX_INST_CMD</span><span class="s2"> &amp;&amp; </span><span class="nv">$GOX_BUILD_CMD</span><span class="s2"> &amp;&amp; exit&#34;</span>
</code></pre></div><p>위 샘플 compile.sh 스크립트는 golang 1.13.1 버전에서 빌드한다.
여러 플랫폼용으로 잘 빌드 되는지 확인하기 위해 <a href="https://github.com/mitchellh/gox">gox</a>를 사용해 빌드한다.
빌드된 바이너리는 host 에 남기기 위해 docker run 명령에 volume 파라미터로 프로젝트 폴더를 연결한다.</p>
<h2 id="빌드-결과">빌드 결과</h2>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ file ./build/**/hello
./build/darwin/386/hello:     Mach-O i386 executable
./build/darwin/amd64/hello:   Mach-O 64-bit x86_64 executable
./build/freebsd/386/hello:    ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>FreeBSD<span class="o">)</span>, statically linked, not stripped
./build/freebsd/amd64/hello:  ELF 64-bit LSB executable, x86-64, version <span class="m">1</span> <span class="o">(</span>FreeBSD<span class="o">)</span>, statically linked, not stripped
./build/freebsd/arm/hello:    ELF 32-bit LSB executable, ARM, EABI5 version <span class="m">1</span> <span class="o">(</span>FreeBSD<span class="o">)</span>, statically linked, not stripped
./build/linux/386/hello:      ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/amd64/hello:    ELF 64-bit LSB executable, x86-64, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/arm/hello:      ELF 32-bit LSB executable, ARM, EABI5 version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/mips/hello:     ELF 32-bit MSB executable, MIPS, MIPS32 version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/mips64/hello:   ELF 64-bit MSB executable, MIPS, MIPS-III version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/mips64le/hello: ELF 64-bit LSB executable, MIPS, MIPS-III version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/mipsle/hello:   ELF 32-bit LSB executable, MIPS, MIPS32 version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/linux/s390x/hello:    ELF 64-bit MSB executable, IBM S/390, version <span class="m">1</span> <span class="o">(</span>SYSV<span class="o">)</span>, statically linked, not stripped
./build/netbsd/386/hello:     ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>NetBSD<span class="o">)</span>, statically linked, <span class="k">for</span> NetBSD 5.99, not stripped
./build/netbsd/amd64/hello:   ELF 64-bit LSB executable, x86-64, version <span class="m">1</span> <span class="o">(</span>NetBSD<span class="o">)</span>, statically linked, <span class="k">for</span> NetBSD 5.99, not stripped
./build/netbsd/arm/hello:     ELF 32-bit LSB executable, ARM, EABI5 version <span class="m">1</span> <span class="o">(</span>NetBSD<span class="o">)</span>, statically linked, <span class="k">for</span> NetBSD 5.99, not stripped
./build/openbsd/386/hello:    ELF 32-bit LSB executable, Intel 80386, version <span class="m">1</span> <span class="o">(</span>OpenBSD<span class="o">)</span>, statically linked, <span class="k">for</span> OpenBSD, not stripped
./build/openbsd/amd64/hello:  ELF 64-bit LSB executable, x86-64, version <span class="m">1</span> <span class="o">(</span>OpenBSD<span class="o">)</span>, statically linked, <span class="k">for</span> OpenBSD, not stripped

</code></pre></div><p>Docker 이미지를 이용하면 비교적 시스템에 영향을 미치지 않고 여러 버전의 golang 에서 기존 프로젝트의 빌드를 테스트 해 볼 수 있다.</p>
]]></content></item><item><title>리눅스의 스레드 구현 살펴보기 - 리눅스는 스레드를 일반 프로세스로 구현한다</title><link>https://byounghoonkim.github.io/posts/2019-03-07-the_linux_implementation_of_threads/</link><pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate><guid>https://byounghoonkim.github.io/posts/2019-03-07-the_linux_implementation_of_threads/</guid><description>&amp;ldquo;리눅스는 스레드를 일반 프로세스로 구현한다.&amp;rdquo; 라는 문구의 의미에 대해 좀더 깊이 살펴보고 어떤 의미를 가지는지 확인해 본다. 책 &amp;l</description><content type="html"><![CDATA[<p>&ldquo;리눅스는 스레드를 일반 프로세스로 구현한다.&rdquo; 라는 문구의 의미에 대해 좀더 깊이 살펴보고 어떤 의미를 가지는지 확인해 본다.</p>
<p>책 &lt;리눅스 커널 심층 분석&gt;의 리눅스 스레드 구현 이라는 장에는 아래와 같은 설명이 나온다.</p>
<blockquote>
<p>The Linux Implementation of Threads
&hellip;
Linux has a unique implementation of threads.
To the Linux kernel, there is no concept of a thread.
Linux implements all threads as standard processes.
The Linux kernel does not provide any special scheduling semantics or data structures to represent threads.
Instead, a thread is merely a process that shares certain resources with other processes.
Each thread has a unique task_struct and appears to the kernel as a normal process—
threads just happen to share resources, such as an address space, with other processes.
This approach to threads contrasts greatly with operating systems such as Microsoft
Windows or Sun Solaris, which have explicit kernel support for threads (and sometimes
call threads lightweight processes).The name “lightweight process” sums up the difference in
philosophies between Linux and other systems.To these other operating systems, threads
are an abstraction to provide a lighter, quicker execution unit than the heavy process.To
Linux, threads are simply a manner of sharing resources between processes (which are
already quite lightweight). For example, assume you have a process that consists of four
threads. On systems with explicit thread support, one process descriptor might exist that,
in turn, points to the four different threads.The process descriptor describes the shared
resources, such as an address space or open files.The threads then describe the resources
they alone possess. Conversely, in Linux, there are simply four processes and thus four
normal task_struct structures.The four processes are set up to share certain resources.
The result is quite elegant
&hellip;</p>
</blockquote>
<p>스레드라는 개념을 명시적으로 구현한 윈도우나 솔라리스 등의 운영체제와는 달리
리눅스에서의 스레드 구현은 단지 프로세스 간에 리소스를 공유 하는 형태로 구현한다고 설명한다.</p>
<p>리눅스에서는 스레드를 생성할 때 스레드 생성과 관련된 명시적인 커널 API(윈도우의 경우 PsCreateSystemThread 와 같은)를
호출하는 것이 대신 프로세스를 클론하고 클론된 프로세스에서 클론한 프로세스의 리소스를 공유하는 형태로 구현한다.</p>
<p>코드로 알아 보기 위해 아래와 같은 스레드 생성 코드를 작성했다.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;sleeping... 100 seconds...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;waiting... </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>위 코드를 컴파일(gcc main.c -lpthread)한 후 strace를 통해 실행하면
아래와 같이 pthread_create 호출 시 clone API 를 호출하는 것을 확인할 수 있다.
(좀더 자세한 사항은 man clone(2) 의 CLONE_THREAD 부분을 참고하기 바란다.)</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; strace ./a.out
...
brk<span class="o">(</span>NULL<span class="o">)</span>                               <span class="o">=</span> 0x55966b82a000
brk<span class="o">(</span>0x55966b84b000<span class="o">)</span>                     <span class="o">=</span> 0x55966b84b000
clone<span class="o">(</span><span class="nv">child_stack</span><span class="o">=</span>0x7f306daeffb0, <span class="nv">flags</span><span class="o">=</span>CLONE_VM<span class="p">|</span>CLONE_FS<span class="p">|</span>CLONE_FILES<span class="p">|</span>CLONE_SIGHAND<span class="p">|</span>CLONE_THREAD<span class="p">|</span>CLONE_SYSVSEM<span class="p">|</span>CLONE_SETTLS<span class="p">|</span>CLONE_PARENT_SETTID<span class="p">|</span>CLONE_CHILD_CLEARTID, parent_
<span class="nv">tidptr</span><span class="o">=</span>0x7f306daf09d0, <span class="nv">tls</span><span class="o">=</span>0x7f306daf0700, <span class="nv">child_tidptr</span><span class="o">=</span>0x7f306daf09d0<span class="o">)</span> <span class="o">=</span> <span class="m">2126</span>                                                                                              
futex<span class="o">(</span>0x7f306dede8c0, FUTEX_WAIT_PRIVATE, 2, NULLsleeping... <span class="m">100</span> seconds...
<span class="o">)</span> <span class="o">=</span> <span class="m">0</span>
write<span class="o">(</span>1, <span class="s2">&#34;waiting... \n&#34;</span>, 12waiting... 
...
</code></pre></div><p>간단하게 나마 리눅스 커널에서는 스레드라는 것이 다른 프로세스의 리소스를 공유하는 프로세스라는 점을 알아 보았다. 그럼 유저 모드에서는 그 영향이 나타날까? thread id 라는 것이 process id 와 동일할 것일까?</p>
<p>위에서 작성한 프로그램을 백그라운드로 실행한다(./a.out &amp;).
그리고 thread 에 관한 정보를 출력하기 위해 ps 명령에 -Lf 옵션을 주어 실행한다.</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">&gt; ./a.out <span class="p">&amp;</span>
<span class="o">[</span>1<span class="o">]</span> <span class="m">4308</span>
waiting... 
sleeping... <span class="m">100</span> seconds...

&gt; ps -Lf
UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
...
bhkim     <span class="m">4308</span>  <span class="m">2028</span>  <span class="m">4308</span>  <span class="m">0</span>    <span class="m">2</span> 23:02 pts/4    00:00:00 ./a.out
bhkim     <span class="m">4308</span>  <span class="m">2028</span>  <span class="m">4310</span>  <span class="m">0</span>    <span class="m">2</span> 23:02 pts/4    00:00:00 ./a.out
...

</code></pre></div><p>ps의 출력 정보 중 PID 4308 이라는 항목으로 두줄의 정보가 나온다.
thread id 정도가 있어야 할 자리에 LWP ID가 출력된다.
첫번째 줄의 LWP 항목은 자신의 PID 와 동일한 값을 가진다.
그리고 두번째 줄의 LWP 항목은 4310 의 값을 가진다.
LWP는 light wight process의 약자로 리눅스 커널이 스레드를 프로세스로 구현함으로 인해 나타난 증상이라고 볼 수 있다.</p>
<p>LWP 항목은 실제로 PID 의 대용으로 사용할 수 있다.
예를 들면, kill 4310 과 같은 명령으로 LWP 4310 인 프로세스를 종료할 수도 있다.</p>
<p>요약,</p>
<ol>
<li>리눅스 커널은 스레드를 프로세스를 이용해 구현한다.</li>
<li>LWP 라는 이름은 리눅스의 스레드 구현에 기인한 산물이다.</li>
<li>리눅스의 커널 구현은 스레드를 명시적으로 구현하는 다른 운영체제와 대조된다.</li>
</ol>
]]></content></item><item><title>Vi의 Esc 기원</title><link>https://byounghoonkim.github.io/posts/2015-02-13-vim-holy-grail-esc-ctrl-bracke-and-jk/</link><pubDate>Fri, 13 Feb 2015 00:00:00 +0000</pubDate><guid>https://byounghoonkim.github.io/posts/2015-02-13-vim-holy-grail-esc-ctrl-bracke-and-jk/</guid><description>Vi 제작자는 자주 모드 전환키로 왜 Esc 키를 선택 했을까? Vi에서 Esc키는 삽입 모드에서 명령 모드로 전환하는 키로 아주 자주 쓰이는 키다. 방향키 대신 hjkl 키로 방향키</description><content type="html"><![CDATA[<p>Vi 제작자는 자주 모드 전환키로 왜 Esc 키를 선택 했을까?</p>
<p>Vi에서 Esc키는 삽입 모드에서 명령 모드로 전환하는 키로 아주 자주 쓰이는 키다.
방향키 대신 hjkl 키로 방향키를 대신할 만큼 단축키 선정에서 효율성을 중시하는 에디터가 자주 쓰는 키를 불편한 Esc로 선정했다는 것은 이해되지 않는다.</p>
<p><a href="http://federico.galassi.net/2012/06/20/the-vim-holy-grail/">The Vim Holy Grail</a>이라는 글에서 힌트를 얻을 수 있다.</p>
<p>인용 요약 하면 아래와 같다.</p>
<ul>
<li>Vi가 만들어질 당시에 쓰였던 키보드는 ADM3A 이란 터미널에 딸려 있는 키보드였다.</li>
<li>이 키보드의 Esc키 위치는 현대 키보드의 탭키 위치로 자주 타이핑 하기에 적당한 위치였다.</li>
<li>이후 키보드 레이아웃이 바뀌면서 Esc는 자주 누르기 불편한 위치로 이동했지만 Esc로 모드 전환 하는 상태는 유지되었다.</li>
</ul>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/KB_Terminal_ADM3A.svg/931px-KB_Terminal_ADM3A.svg.png" alt="ADM3A keyboard layout"></p>
]]></content></item></channel></rss>